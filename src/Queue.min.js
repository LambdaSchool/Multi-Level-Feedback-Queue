const { SchedulerInterrupt: SchedulerInterrupt } = require("./constants/index");
class Queue {
  constructor(scheduler, quantum, priorityLevel, queueType) {
    (this.processes = []),
      (this.priorityLevel = priorityLevel),
      (this.scheduler = scheduler),
      (this.quantum = quantum),
      (this.quantumClock = 0),
      (this.queueType = queueType);
  }
  enqueue(process) {
    return process.setParentQueue(this), this.processes.push(process), process;
  }
  dequeue() {
    return this.processes.shift();
  }
  peek() {
    return this.processes[0];
  }
  isEmpty() {
    return 0 === this.processes.length;
  }
  getPriorityLevel() {
    return this.priorityLevel;
  }
  getQueueType() {
    return this.queueType;
  }
  manageTimeSlice(currentProcess, time) {
    currentProcess.isStateChanged()
      ? (this.quantumClock = 0)
      : ((this.quantumClock += time),
        this.quantumClock >= this.quantum &&
          ((this.quantumClock = 0),
          this.dequeue(),
          currentProcess.isFinished() ||
            this.scheduler.handleInterrupt(
              this,
              currentProcess,
              SchedulerInterrupt.LOWER_PRIORITY
            )));
  }
  doCPUWork(time) {
    const process = this.peek();
    process.executeProcess(time), this.manageTimeSlice(process, time);
  }
  doBlockingWork(time) {
    const process = this.peek();
    process.executeBlockingProcess(time), this.manageTimeSlice(process, time);
  }
  emitInterrupt(source, interrupt) {
    const index = this.processes.indexOf(source);
    this.processes.splice(index, 1),
      interrupt === SchedulerInterrupt.PROCESS_BLOCKED
        ? this.scheduler.handleInterrupt(
            this,
            source,
            SchedulerInterrupt.PROCESS_BLOCKED
          )
        : interrupt === SchedulerInterrupt.PROCESS_READY &&
          this.scheduler.handleInterrupt(
            this,
            source,
            SchedulerInterrupt.PROCESS_READY
          );
  }
}
module.exports = Queue;
